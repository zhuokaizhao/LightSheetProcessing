#include <teem/nrrd.h>
#include "proj.h"
#include "util.h"
#include "skimczi.h"

#include <boost/filesystem.hpp>
#include <boost/range/iterator_range.hpp>

// these are used while iterating filesystem
#include <dirent.h>
#include <cstring>
#include <iostream>
#include <vector>
#include <memory>

using namespace std;
namespace fs = boost::filesystem;

/*
// helper function that checks if a string is a number
bool is_number(const string& s)
{
    std::string::const_iterator it = s.begin();
    while (it != s.end() && std::isdigit(*it)) ++it;
    return !s.empty() && it == s.end();
}

// Helper function that checks if given string path is of a Directory
bool checkIfDirectory(std::string filePath)
{
	try 
    {
		// Create a Path object from given path string
		fs::path pathObj(filePath);
		// Check if path exists and is of a directory file
        if (fs::exists(pathObj) && fs::is_directory(pathObj))
            return true;
		// if (boost::filesystem::exists(pathObj) && boost::filesystem::is_directory(pathObj))
		// 	return true;
	}
	catch (fs::filesystem_error & e)
	{
		std::cerr << e.what() << std::endl;
	}
	return false;
}

// helper function that gets all the file names in a directory
vector<string> GetDirectoryFiles(const std::string& dir) 
{
    std::vector<std::string> files;
    std::shared_ptr<DIR> directory_ptr(opendir(dir.c_str()), [](DIR* dir){ dir && closedir(dir); });
    struct dirent *dirent_ptr;
    
    if (!directory_ptr) 
    {
        std::cout << "Error opening : "  << dir << std::endl;
        return files;
    }
    
    while ((dirent_ptr = readdir(directory_ptr.get())) != nullptr) 
    {
        files.push_back(std::string(dirent_ptr->d_name));
    }
    return files;
}
*/

void setup_proj(CLI::App &app) {
    auto opt = std::make_shared<projOptions>();
    auto sub = app.add_subcommand("proj", "Create projection files based on nhdr file that has been generated by lsp skim.");

    //sub->add_option("-n, --file_number", opt->file_number, "Target file number. (Starts at 0)")->required();
    sub->add_option("-i, --nhdr_path", opt->nhdr_path, "Input nhdr file path. (Default: ./nhdr)")->required();
    //sub->add_option("-n, --czi_path", opt->czi_path, "Initial location that saves all the czi files. (Default: ./czi)")->required();
    sub->add_option("-o, --proj_path", opt->proj_path, "Where to output projection files. (Default: ./proj)")->required();
    sub->add_option("-b, --base_name", opt->base_name, "Same base name, which is normally the date of data")->required();
    sub->add_option("-v, --verbose", opt->verbose, "Turn on (1) or off (0) debug messages, by default turned off");

    sub->set_callback([opt]() 
    {
        // vector of strings that contains all the valid nhdr names
        vector<string> allNhdrFileNames;

        // first determine if input nhdr_path is valid
        if (checkIfDirectory(opt->nhdr_path))
        {
            if (opt->verbose)
                cout << "nhdr input directory " << opt->nhdr_path << " is valid" << endl;
            
            // count the number of files
            const vector<string> files = GetDirectoryFiles(opt->nhdr_path);
            // note that the number starts counting at 1 (not 0, don't mix this with the naming of the data inputs)
            int totalNum = files.size();
            int nhdrNum = 0;
            int xmlNum = 0;

            // since files include .nhdr and .xml file in pairs, we want to count individual number
            for (const string curFile : files) 
            {
                // check if input file is a .nhdr file
                int nhdr_suff = curFile.rfind(".nhdr");
                
                /* we don't need xml actually...
                int xml_suff = curFile.rfind(".xml");
                if (!nhdr_suff || !xml_suff || (nhdr_suff != curFile.length() - 5) || (xml_suff != curFile.length() - 4)) 
                {
                    if (opt->verbose)
                        cout << "Current input file " + curFile + " does not end with .nhdr or .xml, should not be counted, continue to the next" << endl;
                    continue;
                }
                else if (!xml_suff || (xml_suff != curFile.length() - 4))
                {
                    if (opt->verbose)
                        cout << "Current input file " + curFile + " ends with .xml, count this file" << endl;
                    xmlNum++;
                }

                // after iterating, we need to check if nhdrNum == xmlNum
                if (nhdrNum != xmlNum)
                    cerr << "Error: the number of nhdr file is not equal to xmlNum" << endl;
                */

                if (nhdr_suff && (nhdr_suff == curFile.length() - 5))
                {
                    if (opt->verbose)
                        cout << "Current input file " + curFile + " ends with .nhdr, count this file" << endl;
                    nhdrNum++;
                    allNhdrFileNames.push_back(curFile);
                }

            }

            // update file number
            opt->file_number = nhdrNum;
            if (opt->verbose)
            {
                cout << endl << "The number of nhdr input files is " << nhdrNum << endl << endl;
                cout << "Starting second loop for processing" << endl << endl;
            }

            // another loop to process files
            for (const string curFile : allNhdrFileNames)
            {
                // we no longer need to check
                // check if input file is a .nhdr file
                /*
                int nhdr_suff = curFile.rfind(".nhdr");

                if (nhdr_suff && (nhdr_suff == curFile.length() - 5))
                {   
                    opt->file_name = curFile;
                    // now we process the files
                    try
                    {
                        Proj(*opt).main();
                    }
                    catch(LSPException &e)
                    {
                        std::cerr << "Exception thrown by " << e.get_func() << "() in " << e.get_file() << ": " << e.what() << std::endl;
                    }
                }
                */
                // if (opt->verbose)
                //     cout << "Currently processing " << curFile << endl;

                // we want to know if this proj file exists (processed before), don't overwrite it
                fs::path curPath(opt->nhdr_path + curFile);
                if (fs::exists(curPath))
                {
                    cout << curFile << " exits, continue to next." << endl;
                    cout << opt->number_of_processed << " out of " << opt->file_number << " files have been processed" << endl;
                    opt->number_of_processed++;
                    continue;
                }

                opt->file_name = curFile;
                try
                {
                    //cout << opt->number_of_processed << " out of " << opt->file_number << " files have been processed" << endl;
                    Proj(*opt).main();
                    opt->number_of_processed++;
                }
                catch(LSPException &e)
                {
                    std::cerr << "Exception thrown by " << e.get_func() << "() in " << e.get_file() << ": " << e.what() << std::endl;
                }
            }
        }
        // single file case
        else
        {
            // the program also handles if input file is a single file
            cout << opt->nhdr_path << " is not a directory, check if it is a valid .nhdr file" << endl;
            const string curFile = opt->nhdr_path;

            if (opt->verbose)
                std::cout << "Current file name is: " << curFile << endl;
            
            // check if input file is a .czi file
            int suff = curFile.rfind(".nhdr");

            if (!suff || (suff != curFile.length() - 5)) 
            {
                if (opt->verbose)
                    cout << "Current input file " + curFile + " does not end with .nhdr, error" << endl;
                return;
            }
            else
            {
                if (opt->verbose)
                    cout << "Current input file " + curFile + " ends with .nhdr, process this file" << endl;

                // update file number
                opt->file_number = 1;   
                opt->file_name = curFile;         
                try 
                {
                    Proj(*opt).main();
                } 
                catch(LSPException &e) 
                {
                    std::cerr << "Exception thrown by " << e.get_func() << "() in " << e.get_file() << ": " << e.what() << std::endl;
                }
            }
        }
        
    });
}


Proj::Proj(projOptions const &opt): opt(opt), mop(airMopNew()) 
{
    if (!checkIfDirectory(opt.proj_path))
    {
        cout << opt.proj_path << " does not exits, but has been created" << endl;
        boost::filesystem::create_directory(opt.proj_path);
    }

    // if the number of file is 1 (single file since count starts at 1), use absolute name
    if (opt.file_number == 1)
    {
        nhdr_name = opt.nhdr_path;
        // in this case we keep the proj file name same as nhdr base name
        int end = nhdr_name.rfind(".nhdr");
        int start = nhdr_name.rfind("/") + 1;
        int length = end - start;
        std::string baseName = nhdr_name.substr(start, length);
        if (opt.verbose)
            cout << "Base name is " << baseName << endl;
        proj_common = opt.proj_path + baseName + "-proj";
    }
    else
    {
        //nhdr_name = opt.nhdr_path + zero_pad(opt.file_number, numZeroPad) + ".nhdr";
        //proj_common = opt.proj_path + zero_pad(opt.file_number, numZeroPad) + "-proj";
        nhdr_name = opt.nhdr_path + opt.file_name;

        if (opt.verbose)
            cout << "Currently processing " << nhdr_name << endl;

        // now we need to understand the sequence number of this file, which is the number after the baseName and before the extension
        int end = nhdr_name.rfind(".nhdr");
        int start = nhdr_name.rfind("_") + 1;
        int length = end - start;
        std::string sequenceNumString = nhdr_name.substr(start, length);

        // if (opt.verbose)
        //     cout << "Sequence number is " << sequenceNumString << endl;

        // check if that is a valid number
        bool isNumber = is_number(sequenceNumString);
        if (!isNumber)
            return;
        
        proj_common = opt.proj_path + opt.base_name + "_" + sequenceNumString + "-proj";
        // if (opt.verbose)
        //     cout << "aaa proj_common is " << proj_common << endl;
    }
}


Proj::~Proj(){
  airMopOkay(mop);
}


void Proj::main(){
    nrrdStateVerboseIO = 0;
    int verbose = opt.verbose;

    if (verbose)
        cout << "Start Proj::main()" << endl;

    // load input nhdr header file
    Nrrd* nin = safe_nrrd_load(mop, nhdr_name);

    //xy proj
    Nrrd* nproj_xy = safe_nrrd_new(mop, (airMopper)nrrdNuke);
    Nrrd* nproj_xy_t[2] = {safe_nrrd_new(mop, (airMopper)nrrdNuke),
                            safe_nrrd_new(mop, (airMopper)nrrdNuke)};
    
    // if (verbose)
    // {
    //     cout << "proj_common is " << proj_common << endl;
    // }
        
    std::string xy = proj_common + "XY.nrrd";

    nrrd_checker(nrrdProject(nproj_xy_t[0], nin, 3, nrrdMeasureMax, nrrdTypeFloat) ||
                    nrrdProject(nproj_xy_t[1], nin, 3, nrrdMeasureMean, nrrdTypeFloat) ||
                    nrrdJoin(nproj_xy, nproj_xy_t, 2, 3, 1), mop, "Error building XY projection:\n", "proj.cpp", "Proj::main");

    nrrdAxisInfoSet_va(nproj_xy, nrrdAxisInfoLabel, "x", "y", "c", "proj");
    // save
    nrrd_checker(nrrdSave(xy.c_str(), nproj_xy, nullptr),
                mop, "Error saving XY projection:\n", "proj.cpp", "Proj::main");
    
    if (verbose)
    {
        cout << "X-Y Projection file has been saved to " << xy << endl;
    }

    //xz proj
    unsigned int permute[4] = {0, 2, 1, 3}; //same permute array for xz and yz coincidently
    std::string xz = proj_common + "XZ.nrrd";
    Nrrd* nproj_xz = safe_nrrd_new(mop, (airMopper)nrrdNuke);
    Nrrd* nproj_xz_t[2] = {safe_nrrd_new(mop, (airMopper)nrrdNuke),
                            safe_nrrd_new(mop, (airMopper)nrrdNuke)};
    nrrd_checker(nrrdProject(nproj_xz_t[0], nin, 1, nrrdMeasureMax, nrrdTypeFloat) ||
                    nrrdProject(nproj_xz_t[1], nin, 1, nrrdMeasureMean, nrrdTypeFloat) ||
                    nrrdJoin(nproj_xz, nproj_xz_t, 2, 3, 1) ||
                    nrrdAxesPermute(nproj_xz, nproj_xz, permute), mop, "Error building XZ projection:\n", "proj.cpp", "Proj::main");

    nrrdAxisInfoSet_va(nproj_xz, nrrdAxisInfoLabel, "x", "z", "c", "proj");
    // save
    nrrd_checker(nrrdSave(xz.c_str(), nproj_xz, nullptr),
                mop, "Error saving XZ projection:\n", "proj.cpp", "Proj::main");
    if (verbose)
    {
        cout << "X-Z Projection file has been saved to " << xz << endl;
    }

    //yz proj
    Nrrd* nproj_yz = safe_nrrd_new(mop, (airMopper)nrrdNuke);
    Nrrd* nproj_yz_t[2] = {safe_nrrd_new(mop, (airMopper)nrrdNuke),
                            safe_nrrd_new(mop, (airMopper)nrrdNuke)};
    std::string yz = proj_common + "YZ.nrrd";
    nrrd_checker(nrrdProject(nproj_yz_t[0], nin, 0, nrrdMeasureMax, nrrdTypeFloat) ||
                    nrrdProject(nproj_yz_t[1], nin, 0, nrrdMeasureMean, nrrdTypeFloat) ||
                    nrrdJoin(nproj_yz, nproj_yz_t, 2, 3, 1) ||
                    nrrdAxesPermute(nproj_yz, nproj_yz, permute),
                mop, "Error building YZ projection:\n", "proj.cpp", "Proj::main");

    nrrdAxisInfoSet_va(nproj_yz, nrrdAxisInfoLabel, "y", "z", "c", "proj");

    // save
    nrrd_checker(nrrdSave(yz.c_str(), nproj_yz, nullptr),
                mop, "Error saving YZ projection:\n", "proj.cpp", "Proj::main");

    if (verbose)
    {
        cout << "Y-Z Projection file has been saved to " << yz << endl;
    }

    cout << opt.number_of_processed << " out of " << opt.file_number << " files have been processed" << endl;

}
